import { execSync } from 'node:child_process';
import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';
import path from 'node:path';
import * as logger from '../utils/logger';

const AUTH_SCHEMA_BLOCK = `
// Auth tables (generated by BetterAuth)
export const sessions = sqliteTable('sessions', {
  id: text('id').primaryKey(),
  userId: text('user_id').notNull().references(() => users.id),
  expiresAt: integer('expires_at', { mode: 'timestamp' }).notNull(),
  ipAddress: text('ip_address'),
  userAgent: text('user_agent'),
});

export const accounts = sqliteTable('accounts', {
  id: text('id').primaryKey(),
  userId: text('user_id').notNull().references(() => users.id),
  provider: text('provider').notNull(),
  providerAccountId: text('provider_account_id').notNull(),
  accessToken: text('access_token'),
  refreshToken: text('refresh_token'),
  expiresAt: integer('expires_at', { mode: 'timestamp' }),
});
`;

const AUTH_ROUTE_FILE = `import { Hono } from 'hono';
import { z } from 'zod';
import { eq } from 'drizzle-orm';
import { db } from '../db';
import { users, sessions } from '../db/schema';

const authRoute = new Hono();

const signupSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  name: z.string().min(1).optional(),
});

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});

authRoute.post('/signup', async (c) => {
  const body = signupSchema.parse(await c.req.json());
  const passwordHash = await Bun.password.hash(body.password);

  const created = await db
    .insert(users)
    .values({
      email: body.email,
      name: body.name ?? null,
      passwordHash,
    })
    .returning();

  return c.json({
    user: {
      id: created[0].id,
      email: created[0].email,
      name: created[0].name,
    },
  }, 201);
});

authRoute.post('/login', async (c) => {
  const body = loginSchema.parse(await c.req.json());

  const user = await db.select().from(users).where(eq(users.email, body.email)).limit(1);
  if (user.length === 0 || !user[0].passwordHash) {
    return c.json({ error: 'Invalid credentials' }, 401);
  }

  const validPassword = await Bun.password.verify(body.password, user[0].passwordHash);
  if (!validPassword) {
    return c.json({ error: 'Invalid credentials' }, 401);
  }

  const sessionId = crypto.randomUUID();
  const expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);

  await db.insert(sessions).values({
    id: sessionId,
    userId: user[0].id,
    expiresAt,
    ipAddress: c.req.header('cf-connecting-ip') || c.req.header('x-forwarded-for') || null,
    userAgent: c.req.header('user-agent') || null,
  });

  return c.json({
    token: sessionId,
    user: {
      id: user[0].id,
      email: user[0].email,
      name: user[0].name,
    },
  });
});

authRoute.post('/logout', async (c) => {
  const token = c.req.header('Authorization')?.split(' ')[1];
  if (token) {
    await db.delete(sessions).where(eq(sessions.id, token));
  }

  return c.json({ message: 'Logged out' });
});

export { authRoute };
`;

const AUTH_MIDDLEWARE_FILE = `import { and, eq, gt } from 'drizzle-orm';
import { createMiddleware } from 'hono/factory';
import { db } from '../db';
import { sessions, users } from '../db/schema';

export interface AuthContext {
  user: {
    id: string;
    email: string;
    name: string | null;
  };
}

function getSessionToken(authHeader: string | undefined): string | null {
  if (!authHeader) return null;

  const parts = authHeader.split(' ');
  if (parts.length !== 2 || parts[0] !== 'Bearer') return null;

  return parts[1];
}

async function validateSession(token: string): Promise<AuthContext['user'] | null> {
  const session = await db
    .select()
    .from(sessions)
    .where(and(eq(sessions.id, token), gt(sessions.expiresAt, new Date())))
    .limit(1);

  if (session.length === 0) return null;

  const user = await db.select().from(users).where(eq(users.id, session[0].userId)).limit(1);
  return user.length > 0 ? user[0] : null;
}

export const requireAuth = createMiddleware<{ Variables: AuthContext }>(async (c, next) => {
  const token = getSessionToken(c.req.header('Authorization'));

  if (!token) {
    return c.json({ error: 'Unauthorized: No token provided' }, 401);
  }

  const user = await validateSession(token);
  if (!user) {
    return c.json({ error: 'Unauthorized: Invalid or expired token' }, 401);
  }

  c.set('user', user);
  await next();
});

export const optionalAuth = createMiddleware<{ Variables: Partial<AuthContext> }>(async (c, next) => {
  const token = getSessionToken(c.req.header('Authorization'));

  if (token) {
    const user = await validateSession(token);
    if (user) {
      c.set('user', user);
    }
  }

  await next();
});

export function getUser(c: { get: (key: 'user') => AuthContext['user'] }): AuthContext['user'] {
  return c.get('user');
}
`;

function appendIfMissing(filePath: string, marker: string, content: string): void {
  const current = readFileSync(filePath, 'utf-8');
  if (current.includes(marker)) {
    return;
  }

  const next = current.trimEnd() + '\n\n' + content.trim() + '\n';
  writeFileSync(filePath, next);
}

function ensurePasswordHashColumn(schemaPath: string): void {
  const current = readFileSync(schemaPath, 'utf-8');
  if (/passwordHash\s*:\s*text\('password_hash'\)/.test(current)) {
    return;
  }

  const usersBlock = current.match(/export\s+const\s+users\s*=\s*sqliteTable\([^]+?\}\);/m);
  if (!usersBlock) {
    logger.warn('Could not find sqlite users table block; skipping passwordHash injection.');
    return;
  }

  const replacement = usersBlock[0].replace(/\n\}\);$/, "\n  passwordHash: text('password_hash').notNull(),\n});");
  writeFileSync(schemaPath, current.replace(usersBlock[0], replacement));
}

function ensureAuthInConfig(projectRoot: string): void {
  const configPath = path.join(projectRoot, 'betterbase.config.ts');
  if (!existsSync(configPath)) return;

  const current = readFileSync(configPath, 'utf-8');
  if (current.includes('auth: {')) return;

  const patterns = [
    {
      regex: /export\s+default\s+\{/,
      replace: `export default {\n  auth: {\n    enabled: true,\n    secret: process.env.AUTH_SECRET,\n    sessionDuration: 30 * 24 * 60 * 60,\n  },`,
    },
    {
      regex: /export\s+default\s+defineConfig\s*\(\s*\{/,
      replace: `export default defineConfig({\n  auth: {\n    enabled: true,\n    secret: process.env.AUTH_SECRET,\n    sessionDuration: 30 * 24 * 60 * 60,\n  },`,
    },
  ];

  let updated = current;
  for (const pattern of patterns) {
    if (pattern.regex.test(updated)) {
      updated = updated.replace(pattern.regex, pattern.replace);
      break;
    }
  }

  if (updated !== current) {
    writeFileSync(configPath, updated);
  } else {
    logger.warn(`Could not automatically patch auth config in ${configPath}. Please add auth config manually.`);
  }
}

function ensureEnvVar(projectRoot: string): void {
  const envPath = path.join(projectRoot, '.env.example');
  if (!existsSync(envPath)) return;

  const env = readFileSync(envPath, 'utf-8');
  if (env.includes('AUTH_SECRET=')) return;

  writeFileSync(envPath, `${env.trimEnd()}\n\n# Auth\nAUTH_SECRET=your-secret-key-here-change-in-production\n`);
}

function ensureRoutesIndexHook(projectRoot: string): void {
  const routesIndexPath = path.join(projectRoot, 'src/routes/index.ts');
  if (!existsSync(routesIndexPath)) return;

  let current = readFileSync(routesIndexPath, 'utf-8');

  if (!current.includes("import { authRoute } from './auth';")) {
    current = current.replace("import { usersRoute } from './users';", "import { usersRoute } from './users';\nimport { authRoute } from './auth';");
  }

  if (!current.includes("app.route('/auth', authRoute);")) {
    current = current.replace("app.route('/api/users', usersRoute);", "app.route('/api/users', usersRoute);\n  app.route('/auth', authRoute);");
  }

  writeFileSync(routesIndexPath, current);
}

export async function runAuthSetupCommand(projectRoot: string = process.cwd()): Promise<void> {
  const resolvedRoot = path.resolve(projectRoot);
  const schemaPath = path.join(resolvedRoot, 'src/db/schema.ts');
  const middlewarePath = path.join(resolvedRoot, 'src/middleware/auth.ts');
  const routePath = path.join(resolvedRoot, 'src/routes/auth.ts');

  if (!existsSync(schemaPath)) {
    throw new Error(`Could not find schema file at ${schemaPath}. Run this command from a BetterBase app root.`);
  }

  logger.info('üîê Setting up authentication...');

  logger.info('üì¶ Installing better-auth...');
  execSync('bun add better-auth', { cwd: resolvedRoot, stdio: 'inherit' });

  logger.info('üìù Adding auth tables to schema...');
  ensurePasswordHashColumn(schemaPath);
  appendIfMissing(schemaPath, "export const sessions = sqliteTable('sessions'", AUTH_SCHEMA_BLOCK);

  logger.info('üõ°Ô∏è  Creating auth middleware...');
  mkdirSync(path.dirname(middlewarePath), { recursive: true });
  if (!existsSync(middlewarePath)) {
    writeFileSync(middlewarePath, AUTH_MIDDLEWARE_FILE);
  } else {
    logger.warn(`Skipping existing middleware file: ${middlewarePath}`);
  }

  logger.info('üß≠ Creating auth routes...');
  mkdirSync(path.dirname(routePath), { recursive: true });
  if (!existsSync(routePath)) {
    writeFileSync(routePath, AUTH_ROUTE_FILE);
  } else {
    logger.warn(`Skipping existing route file: ${routePath}`);
  }
  ensureRoutesIndexHook(resolvedRoot);

  logger.info('‚öôÔ∏è  Updating config...');
  ensureAuthInConfig(resolvedRoot);
  ensureEnvVar(resolvedRoot);

  logger.success('Authentication setup complete!');
  logger.info('Next steps:');
  logger.info('1. Set AUTH_SECRET in .env');
  logger.info('2. Run: bun run db:push');
  logger.info('3. Use requireAuth middleware on protected routes');
}
